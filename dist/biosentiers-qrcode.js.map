{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap bd13329c4b4a07426665","webpack:///./src/biosentiers-qrcode.js","webpack:///./src/formats/v0.js","webpack:///./src/binary/bitmask.js","webpack:///./src/binary/timestamp.js","webpack:///./src/binary/uint.js","webpack:///./src/binary/utf8-string.js","webpack:///./src/binary/encoder.js","webpack:///./src/binary/byte.js","webpack:///./src/binary/decoder.js"],"names":["bioqr","encode","decode","data","options","bytes","version","Error","format","convertBytesToString","convertStringToBytes","map","byte","String","fromCodePoint","ensureByte","join","string","split","char","charCodeAt","FORMAT_VERSION","FORMAT_LENGTH","CREATOR_NAME_LENGTH","EXCURSION_ID_LENGTH","EXCURSION_NAME_LENGTH","PARTICIPANT_ID_LENGTH","PARTICIPANT_NAME_LENGTH","TYPES","encoder","add","creatorName","excursionId","excursionDate","excursionName","participantId","participantName","types","zones","length","decoder","decoded","get","offset","values","references","forEach","value","i","bitmaskIndex","indexOf","Number","isInteger","mask","push","dateOrTimestamp","timestamp","getTime","minutes","Math","floor","Date","number","byteSize","bits","max","pow","bound","bitShift","currentByte","stringLength","utf8Bytes","stringToUtf8Bytes","j","remainingBytes","stringBytes","slice","rawString","decodeURIComponent","escape","trim","unescape","encodeURIComponent","Encoder","encodeFunc","currentLength","args","unshift","result","apply","undefined","Decoder","decodeFunc","lastArg"],"mappings":"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","file":"biosentiers-qrcode.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bioqr\"] = factory();\n\telse\n\t\troot[\"bioqr\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bd13329c4b4a07426665\n **/","import { encode as v0Encode, decode as v0Decode } from './formats/v0';\n\nconst bioqr = {\n  encode: encode,\n  decode: decode\n};\n\nfunction encode(data, options) {\n  options = options || {};\n\n  let bytes;\n  switch (data.version) {\n    case 0:\n      bytes = v0Encode(data, options);\n      break;\n    default:\n      throw new Error(`Unknown format version ${data.version}`);\n  }\n\n  if (options.format == 'string') {\n    return convertBytesToString(bytes);\n  } else {\n    return bytes;\n  }\n}\n\nfunction decode(data, options) {\n\n  let bytes;\n  if (typeof(data) == 'string') {\n    bytes = convertStringToBytes(data);\n  } else {\n    bytes = data;\n  }\n\n  const version = bytes[0];\n  switch (version) {\n    case 0:\n      return v0Decode(bytes, options);\n    default:\n      throw new Error(`Data is not in a known format version ${version}`);\n  }\n}\n\n/**\n * Converts a byte array to a string.\n */\nfunction convertBytesToString(bytes) {\n  return bytes.map(function(byte) {\n    return String.fromCodePoint(ensureByte(byte));\n  }).join('');\n}\n\n/**\n * Converts a string to a byte array.\n */\nfunction convertStringToBytes(string) {\n  return string.split('').map(function(char) {\n    return char.charCodeAt(0);\n  });\n}\n\nexport default bioqr;\nexport { encode, decode };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/biosentiers-qrcode.js\n **/","import { encode as encodeBitmask, decode as decodeBitmask } from '../binary/bitmask';\nimport { encode as encodeTimestamp, decode as decodeTimestamp } from '../binary/timestamp';\nimport { encode as encodeUint, decode as decodeUint } from '../binary/uint';\nimport { encode as encodeUtf8String, decode as decodeUtf8String } from '../binary/utf8-string';\nimport Encoder from '../binary/encoder';\nimport Decoder from '../binary/decoder';\n\nconst FORMAT_VERSION = 0;\nconst FORMAT_LENGTH = 134;\nconst CREATOR_NAME_LENGTH = 40;\nconst EXCURSION_ID_LENGTH = 5;\nconst EXCURSION_NAME_LENGTH = 60;\nconst PARTICIPANT_ID_LENGTH = 2;\nconst PARTICIPANT_NAME_LENGTH = 20;\nconst TYPES = [ 'bird', 'butterfly', 'flower', 'tree'  ];\n\nexport function encode(data, options) {\n  options = options || {};\n\n  var encoder = new Encoder();\n  encoder.add(encodeUint, FORMAT_VERSION, 1);\n  encoder.add(encodeUtf8String, data.creatorName, CREATOR_NAME_LENGTH);\n  encoder.add(encodeUtf8String, data.excursionId, EXCURSION_ID_LENGTH);\n  encoder.add(encodeTimestamp, data.excursionDate);\n  encoder.add(encodeUtf8String, data.excursionName, EXCURSION_NAME_LENGTH);\n  encoder.add(encodeUtf8String, data.participantId, PARTICIPANT_ID_LENGTH);\n  encoder.add(encodeUtf8String, data.participantName, PARTICIPANT_NAME_LENGTH);\n  encoder.add(encodeBitmask, data.types, options.types || TYPES);\n  encoder.add(encodeBitmask, data.zones);\n\n  if (encoder.bytes.length != FORMAT_LENGTH) {\n    throw new Error(`Format 0 byte length should be 134 (got ${encoder.bytes.length})`);\n  }\n\n  return encoder.bytes;\n}\n\nexport function decode(string, options) {\n  options = options || {};\n\n  const decoder = new Decoder(string);\n  if (decoder.bytes.length != FORMAT_LENGTH) {\n    throw new Error(`Format 0 byte length should be 134 (got ${decoder.bytes.length})`);\n  }\n\n  const decoded = {};\n  decoded.version = decoder.get(decodeUint, 1);\n  decoded.creatorName = decoder.get(decodeUtf8String, CREATOR_NAME_LENGTH);\n  decoded.excursionId = decoder.get(decodeUtf8String, EXCURSION_ID_LENGTH);\n  decoded.excursionDate = decoder.get(decodeTimestamp, 4);\n  decoded.excursionName = decoder.get(decodeUtf8String, EXCURSION_NAME_LENGTH);\n  decoded.participantId = decoder.get(decodeUtf8String, PARTICIPANT_ID_LENGTH);\n  decoded.participantName = decoder.get(decodeUtf8String, PARTICIPANT_NAME_LENGTH);\n  decoded.types = decoder.get(decodeBitmask, TYPES);\n  decoded.zones = decoder.get(decodeBitmask);\n\n  return decoded;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/formats/v0.js\n **/","/**\n * Fills a byte array with a 1-byte bitmask that can be used to serialize up to 8 boolean flags.\n *\n * If no references are given, values must be numbers from 0 to 7.\n * For example, the values [ 1, 3 ] would be encoded as the integer 10 (or 00001010 in binary).\n *\n * If references are given, then each value must be one of the reference values.\n * The references array must not contain more than 32 items.\n * For example, the values [ 'foo', 'baz' ] with references [ 'foo', 'bar', 'baz' ]\n * would be encoded as the integer 5 (or 00000101 in binary).\n */\nexport function encode(bytes, offset, values, references) {\n  let byte = 0;\n\n  values.forEach(function(value, i) {\n\n    let bitmaskIndex = value;\n\n    // If references are given, convert the value to its index in the reference array\n    if (references) {\n      bitmaskIndex = references.indexOf(value);\n      if (bitmaskIndex < 0) {\n        throw new Error(`Unknown bitmask value ${value} (allowed: ${references.join(', ')})`);\n      } else if (bitmaskIndex > 7) {\n        throw new Error(`References have too many values (${references.length} > 32)`);\n      }\n    } else if (!Number.isInteger(bitmaskIndex) || bitmaskIndex < 0 || bitmaskIndex > 31) {\n      throw new Error(`Bitmask value ${i} must be an integer between 0 and 31 or one of the reference values (got ${bitmaskIndex})`);\n    }\n\n    // Set the correct bit to 1 in the bitmask\n    byte = byte | (1 << bitmaskIndex);\n  });\n\n  // Add the byte to the array\n  bytes[offset] = byte;\n}\n\n/**\n * Decodes up to 8 boolean flags from a 1-byte bitmask at the specified position in a byte array.\n *\n * If no references are given, the indices of the active flags are returned, e.g. [ 1, 3 ].\n *\n * If references are given, the indices are converted to the correspond reference values,\n * e.g. [ 'foo', 'baz' ] if the decoded flags are [ 0, 2 ] and the references are [ 'foo', 'bar', 'baz' ].\n */\nexport function decode(bytes, offset, references) {\n\n  const values = [];\n  const byte = bytes[offset];\n\n  // Iterate over the 8 bits\n  for (let i = 0; i < 8; i++) {\n    // Check whether the bit at the current position is 1\n    const mask = 1 << i;\n    if ((byte & mask) > 0) {\n      // Add the index (or reference value) to the result array if that is the case\n      if (!references) {\n        values.push(i);\n      } else if (references[i]) {\n        values.push(references[i]);\n      }\n    }\n  }\n\n  return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/bitmask.js\n **/","import { encode as encodeUint, decode as decodeUint } from '../binary/uint';\n\n/**\n * Fills a byte array with a 4-byte integer representing the specified date in minutes.\n * Seconds and milliseconds are lost in the conversion.\n */\nexport function encode(bytes, offset, dateOrTimestamp) {\n\n  const timestamp = typeof(dateOrTimestamp.getTime) == 'function' ? dateOrTimestamp.getTime() : dateOrTimestamp;\n  if (!Number.isInteger(timestamp)) {\n    throw new Error(`Timestamp must be an integer or a date (got a value of type ${typeof(timestamp)})`)\n  } else if (timestamp < 0) {\n    throw new Error(`Timestamp must be positive (got ${timestamp})`);\n  }\n\n  const minutes = Math.floor(timestamp / 1000);\n  return encodeUint(bytes, offset, minutes, 4);\n}\n\n/**\n * Decodes a date from a 4-byte number of minutes at the specified position in a byte array.\n */\nexport function decode(bytes, offset) {\n  const minutes = decodeUint(bytes, offset, 4);\n  return new Date(minutes * 1000);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/timestamp.js\n **/","/**\n * Fills a byte array with the specified integer's bytes (in big endian order).\n *\n * Unsigned integers may only be serialized up to a precision of 6 bytes\n * (JavaScript numbers are doubles with a significand of 52 bits).\n */\nexport function encode(bytes, offset, number, byteSize) {\n  if (!Number.isInteger(number)) {\n    throw new Error(`Number must be an integer`);\n  } else if (number < 0) {\n    throw new Error(`Unsigned integer cannot be smaller than zero (got ${number})`);\n  } else if (byteSize < 1) {\n    throw new Error(`Unsigned integer cannot be encoded with less than one byte`);\n  } else if (byteSize > 6) {\n    throw new Error(`Unsigned integer cannot be encoded with more than seven bytes`);\n  }\n\n  // Ensure the number is not larger than the maximum allowed by the specified byte size\n  const bits = byteSize * 8;\n  const max = Math.pow(2, bits) - 1;\n  if (number > max) {\n    throw new Error(`Unsigned ${byteSize} bytes integer cannot be greater than ${max} (got ${number})`);\n  }\n\n  // Add the specified number of bytes\n  const bound = offset + byteSize;\n  for (let i = offset; i < bound; i++) {\n    // For each byte, right-shift the number by the correct amount\n    // and take the last 8 bits (with & 0xFF) to obtain the byte to store at that position\n    // (e.g. for a 4 bytes integer, the first byte is right-shifted by 24,\n    // the second by 16, the third by 8 and the fourth by 0)\n    const bitShift = (bound - i - 1) * 8;\n    bytes[i] = 0xFF & (number >> bitShift);\n  }\n}\n\n/**\n * Decodes an unsigned integer's bytes from the specified portion of a byte array (in big endian order).\n */\nexport function decode(bytes, offset, byteSize) {\n  if (byteSize < 1 || byteSize > 6) {\n    throw new Error(`Unsigned integer byte size must be between 1 and 6 (got ${byteSize})`);\n  }\n\n  let number = 0;\n  const bound = offset + byteSize;\n\n  // Iterate byte by byte over the specified range (from offset to offset + byteSize)\n  for (let i = offset; i < bound; i++) {\n    // Shift each byte's bits by the correct amount\n    // and add them to the result number\n    // (e.g. for a 4 bytes integer, the first byte is left-shifted by 24,\n    // the second by 16, the third by 8 and the fourth by 0)\n    const bitShift = (bound - i - 1) * 8;\n    number = number | (bytes[i] << bitShift);\n  }\n\n  return number;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/uint.js\n **/","/**\n * Fills a byte array with the UTF-8 bytes of the specified string.\n *\n * If the string is longer than the specified length (in bytes), extra bytes are not serialized.\n * Extra spaces at the end of the string will be lost when decoding, as spaces are used for padding.\n */\nexport function encode(bytes, offset, string, length) {\n\n  let currentByte = offset;\n  const stringLength = string.length;\n\n  // For each character in the string...\n  for (let i = 0; i < stringLength; i++) {\n\n    const char = string[i];\n\n    // Convert the character to an array of UTF-8 bytes (1 to 4 bytes per character)\n    const utf8Bytes = stringToUtf8Bytes(char);\n\n    // Stop here if there are too many bytes (the rest of the string is ignored)\n    if (currentByte + utf8Bytes.length > offset + length) {\n      break;\n    }\n\n    // Add the character's UTF-8 bytes to the byte array\n    for (let j = 0; j < utf8Bytes.length; j++) {\n      bytes[currentByte + j] = utf8Bytes[j];\n    }\n\n    currentByte += utf8Bytes.length;\n  }\n\n  // If the string is not long enough to fill the expected length, pad it with spaces\n  const remainingBytes = offset + length - currentByte;\n  for (let i = 0; i < remainingBytes; i++) {\n    bytes.push(0x20); // space\n  }\n\n  return bytes;\n}\n\n/**\n * Decodes a string from the UTF-8 bytes in the specified portion of a byte array.\n */\nexport function decode(bytes, offset, length) {\n\n  const stringBytes = bytes.slice(offset, offset + length);\n  const rawString = stringBytes.map(function(byte) {\n    return String.fromCodePoint(byte);\n  }).join('');\n\n  return decodeURIComponent(escape(rawString)).trim();\n}\n\n/**\n * Convers a string to an array containing all its character's UTF-8 bytes (1 to 4 bytes per character).\n */\nfunction stringToUtf8Bytes(string) {\n  return unescape(encodeURIComponent(string)).split('').map(function(char) {\n    return char.charCodeAt(0);\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/utf8-string.js\n **/","import { ensureByte } from '../binary/byte';\n\n/**\n * Utility class to progressively build a byte array and keep track of the current offset.\n */\nexport default class Encoder {\n\n  /**\n   * Constructs an encoder with an empty byte array.\n   */\n  constructor() {\n    this.bytes = [];\n    this.offset = 0;\n  }\n\n  /**\n   * Calls the specified encoding function with this encoder's internal byte array, the\n   * current offset and the specified extra arguments. It's the responsibility of the\n   * encoding function to add more bytes to the array starting at the specified offset.\n   *\n   * The encoder will automatically increment its current offset by the number of new bytes\n   * added to the array, so subsequent calls will invoke encoding functions with greater offsets.\n   */\n  add(encodeFunc, ...args) {\n\n    const currentLength = this.bytes.length;\n    args.unshift(this.bytes, this.offset);\n\n    var result = encodeFunc.apply(undefined, args);\n    this.offset += (this.bytes.length - currentLength);\n\n    return result;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/encoder.js\n **/","/**\n * Returns the specified value unchanged, but throws an error if it is not an integer between 0 and 255.\n */\nexport function ensureByte(byte) {\n  if (!Number.isInteger(byte)) {\n    throw new Error(`Byte is not an integer (${byte})`);\n  } else if (byte < 0) {\n    throw new Error(`Byte is too small (${byte} < 0)`)\n  } else if (byte > 255) {\n    throw new Error(`Byte is too large (${byte} > 255)`);\n  }\n\n  return byte;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/byte.js\n **/","import { ensureByte } from '../binary/byte';\n\n/**\n * Utility class to progressively decode a byte array and keep track of the current offset.\n */\nexport default class Decoder {\n\n  /**\n   * Constructs a decoder for the specified byte array.\n   *\n   * A string can also be given in place of the byte array.\n   * It should contain only characters that can be represented with 1 byte in UTF-8.\n   */\n  constructor(bytes) {\n    this.offset = 0;\n    this.bytes = bytes;\n  }\n\n  /**\n   * Calls the specified decoding function with this decoder's internal byte array, the\n   * current offset and the specified extra arguments, and returns the result. It's the\n   * responsibility of the decoding function to extract the relevant bytes from the array,\n   * starting at the specified offset.\n   *\n   * If the last argument passed to the decoding function is a positive integer, the\n   * decoder will interpret it as the number of bytes that have been decoded and increment\n   * the current offset by that value. Otherwise, it will assume that only 1 byte has been\n   * decoded. Add an extra number argument if that is not the case.\n   */\n  get(decodeFunc, ...args) {\n\n    const lastArg = args.length >= 1 ? args[args.length - 1] : undefined;\n\n    args.unshift(this.bytes, this.offset);\n\n    var result = decodeFunc.apply(undefined, args);\n\n    if (Number.isInteger(lastArg) && lastArg >= 1) {\n      this.offset += lastArg;\n    } else {\n      this.offset++;\n    }\n\n    return result;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/decoder.js\n **/"],"sourceRoot":""}