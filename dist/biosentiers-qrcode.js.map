{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap bc21311c10b991f905bc","webpack:///./src/biosentiers-qrcode.js","webpack:///./src/formats/v0.js","webpack:///./src/binary/bitmask.js","webpack:///./src/binary/timestamp.js","webpack:///./src/binary/uint.js","webpack:///./src/binary/utf8-string.js","webpack:///./src/binary/encoder.js","webpack:///./src/binary/byte.js","webpack:///./src/binary/decoder.js"],"names":["bioqr","encode","decode","data","options","version","Error","string","charCodeAt","FORMAT_VERSION","FORMAT_LENGTH","CREATOR_NAME_LENGTH","EXCURSION_ID_LENGTH","EXCURSION_NAME_LENGTH","PARTICIPANT_ID_LENGTH","PARTICIPANT_NAME_LENGTH","TYPES","encoder","add","creatorName","excursionId","excursionDate","excursionName","participantId","participantName","types","zones","bytes","length","toString","decoder","decoded","get","offset","values","references","byte","forEach","value","i","bitmaskIndex","indexOf","join","Number","isInteger","mask","push","dateOrTimestamp","timestamp","getTime","minutes","Math","floor","Date","number","byteSize","bits","max","pow","bound","bitShift","currentByte","stringLength","char","utf8Bytes","stringToUtf8Bytes","j","remainingBytes","stringBytes","slice","rawString","map","String","fromCodePoint","decodeURIComponent","escape","trim","unescape","encodeURIComponent","split","Encoder","encodeFunc","currentLength","args","unshift","result","apply","undefined","ensureByte","Decoder","decodeFunc","lastArg"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;;AAEA,KAAMA,QAAQ;AACZC,WAAQA,MADI;AAEZC,WAAQA;AAFI,EAAd;;AAKA,UAASD,MAAT,CAAgBE,IAAhB,EAAsBC,OAAtB,EAA+B;AAC7B,WAAQD,KAAKE,OAAb;AACE,UAAK,CAAL;AACE,cAAO,eAASF,IAAT,EAAeC,OAAf,CAAP;AACF;AACE,aAAM,IAAIE,KAAJ,6BAAoCH,KAAKE,OAAzC,CAAN;AAJJ;AAMD;;AAED,UAASH,MAAT,CAAgBK,MAAhB,EAAwBH,OAAxB,EAAiC;AAC/B,OAAMC,UAAUE,OAAOC,UAAP,CAAkB,CAAlB,CAAhB;AACA,WAAQH,OAAR;AACE,UAAK,CAAL;AACE,cAAO,eAASE,MAAT,EAAiBH,OAAjB,CAAP;AACF;AACE,aAAM,IAAIE,KAAJ,8CAAqDD,OAArD,CAAN;AAJJ;AAMD;;mBAEcL,K;SACNC,M,GAAAA,M;SAAQC,M,GAAAA,M;;;;;;;;;;;SCXDD,M,GAAAA,M;SAqBAC,M,GAAAA,M;;AArChB;;AACA;;AACA;;AACA;;AACA;;;;AACA;;;;;;AAEA,KAAMO,iBAAiB,CAAvB;AACA,KAAMC,gBAAgB,GAAtB;AACA,KAAMC,sBAAsB,EAA5B;AACA,KAAMC,sBAAsB,CAA5B;AACA,KAAMC,wBAAwB,EAA9B;AACA,KAAMC,wBAAwB,CAA9B;AACA,KAAMC,0BAA0B,EAAhC;AACA,KAAMC,QAAQ,CAAE,MAAF,EAAU,WAAV,EAAuB,QAAvB,EAAiC,MAAjC,CAAd;;AAEO,UAASf,MAAT,CAAgBE,IAAhB,EAAsBC,OAAtB,EAA+B;AACpCA,aAAUA,WAAW,EAArB;;AAEA,OAAIa,UAAU,uBAAd;AACAA,WAAQC,GAAR,eAAwBT,cAAxB,EAAwC,CAAxC;AACAQ,WAAQC,GAAR,qBAA8Bf,KAAKgB,WAAnC,EAAgDR,mBAAhD;AACAM,WAAQC,GAAR,qBAA8Bf,KAAKiB,WAAnC,EAAgDR,mBAAhD;AACAK,WAAQC,GAAR,oBAA6Bf,KAAKkB,aAAlC;AACAJ,WAAQC,GAAR,qBAA8Bf,KAAKmB,aAAnC,EAAkDT,qBAAlD;AACAI,WAAQC,GAAR,qBAA8Bf,KAAKoB,aAAnC,EAAkDT,qBAAlD;AACAG,WAAQC,GAAR,qBAA8Bf,KAAKqB,eAAnC,EAAoDT,uBAApD;AACAE,WAAQC,GAAR,kBAA2Bf,KAAKsB,KAAhC,EAAuCrB,QAAQqB,KAAR,IAAiBT,KAAxD;AACAC,WAAQC,GAAR,kBAA2Bf,KAAKuB,KAAhC;;AAEA,OAAIT,QAAQU,KAAR,CAAcC,MAAd,IAAwBlB,aAA5B,EAA2C;AACzC,WAAM,IAAIJ,KAAJ,8CAAqDW,QAAQU,KAAR,CAAcC,MAAnE,OAAN;AACD;;AAED,UAAOX,QAAQY,QAAR,EAAP;AACD;;AAEM,UAAS3B,MAAT,CAAgBK,MAAhB,EAAwBH,OAAxB,EAAiC;AACtCA,aAAUA,WAAW,EAArB;;AAEA,OAAM0B,UAAU,sBAAYvB,MAAZ,CAAhB;AACA,OAAIuB,QAAQH,KAAR,CAAcC,MAAd,IAAwBlB,aAA5B,EAA2C;AACzC,WAAM,IAAIJ,KAAJ,8CAAqDwB,QAAQH,KAAR,CAAcC,MAAnE,OAAN;AACD;;AAED,OAAMG,UAAU,EAAhB;AACAA,WAAQ1B,OAAR,GAAkByB,QAAQE,GAAR,eAAwB,CAAxB,CAAlB;AACAD,WAAQZ,WAAR,GAAsBW,QAAQE,GAAR,qBAA8BrB,mBAA9B,CAAtB;AACAoB,WAAQX,WAAR,GAAsBU,QAAQE,GAAR,qBAA8BpB,mBAA9B,CAAtB;AACAmB,WAAQV,aAAR,GAAwBS,QAAQE,GAAR,oBAA6B,CAA7B,CAAxB;AACAD,WAAQT,aAAR,GAAwBQ,QAAQE,GAAR,qBAA8BnB,qBAA9B,CAAxB;AACAkB,WAAQR,aAAR,GAAwBO,QAAQE,GAAR,qBAA8BlB,qBAA9B,CAAxB;AACAiB,WAAQP,eAAR,GAA0BM,QAAQE,GAAR,qBAA8BjB,uBAA9B,CAA1B;AACAgB,WAAQN,KAAR,GAAgBK,QAAQE,GAAR,kBAA2BhB,KAA3B,CAAhB;AACAe,WAAQL,KAAR,GAAgBI,QAAQE,GAAR,iBAAhB;;AAEA,UAAOD,OAAP;AACD,E;;;;;;;;;;;SC9Ce9B,M,GAAAA,M;SAmCAC,M,GAAAA,M;AA9ChB;;;;;;;;;;;AAWO,UAASD,MAAT,CAAgB0B,KAAhB,EAAuBM,MAAvB,EAA+BC,MAA/B,EAAuCC,UAAvC,EAAmD;AACxD,OAAIC,OAAO,CAAX;;AAEAF,UAAOG,OAAP,CAAe,UAASC,KAAT,EAAgBC,CAAhB,EAAmB;;AAEhC,SAAIC,eAAeF,KAAnB;;AAEA;AACA,SAAIH,UAAJ,EAAgB;AACdK,sBAAeL,WAAWM,OAAX,CAAmBH,KAAnB,CAAf;AACA,WAAIE,eAAe,CAAnB,EAAsB;AACpB,eAAM,IAAIlC,KAAJ,4BAAmCgC,KAAnC,mBAAsDH,WAAWO,IAAX,CAAgB,IAAhB,CAAtD,OAAN;AACD,QAFD,MAEO,IAAIF,eAAe,CAAnB,EAAsB;AAC3B,eAAM,IAAIlC,KAAJ,uCAA8C6B,WAAWP,MAAzD,YAAN;AACD;AACF,MAPD,MAOO,IAAI,CAACe,OAAOC,SAAP,CAAiBJ,YAAjB,CAAD,IAAmCA,eAAe,CAAlD,IAAuDA,eAAe,EAA1E,EAA8E;AACnF,aAAM,IAAIlC,KAAJ,oBAA2BiC,CAA3B,iFAAwGC,YAAxG,OAAN;AACD;;AAED;AACAJ,YAAOA,OAAQ,KAAKI,YAApB;AACD,IAlBD;;AAoBA;AACAb,SAAMM,MAAN,IAAgBG,IAAhB;AACD;;AAED;;;;;;;;AAQO,UAASlC,MAAT,CAAgByB,KAAhB,EAAuBM,MAAvB,EAA+BE,UAA/B,EAA2C;;AAEhD,OAAMD,SAAS,EAAf;AACA,OAAME,OAAOT,MAAMM,MAAN,CAAb;;AAEA;AACA,QAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAI,CAApB,EAAuBA,GAAvB,EAA4B;AAC1B;AACA,SAAMM,OAAO,KAAKN,CAAlB;AACA,SAAI,CAACH,OAAOS,IAAR,IAAgB,CAApB,EAAuB;AACrB;AACA,WAAI,CAACV,UAAL,EAAiB;AACfD,gBAAOY,IAAP,CAAYP,CAAZ;AACD,QAFD,MAEO,IAAIJ,WAAWI,CAAX,CAAJ,EAAmB;AACxBL,gBAAOY,IAAP,CAAYX,WAAWI,CAAX,CAAZ;AACD;AACF;AACF;;AAED,UAAOL,MAAP;AACD,E;;;;;;;;;;;;;;SC5DejC,M,GAAAA,M;SAgBAC,M,GAAAA,M;;AAtBhB;;AAEA;;;;AAIO,UAASD,MAAT,CAAgB0B,KAAhB,EAAuBM,MAAvB,EAA+Bc,eAA/B,EAAgD;;AAErD,OAAMC,YAAY,OAAOD,gBAAgBE,OAAvB,IAAmC,UAAnC,GAAgDF,gBAAgBE,OAAhB,EAAhD,GAA4EF,eAA9F;AACA,OAAI,CAACJ,OAAOC,SAAP,CAAiBI,SAAjB,CAAL,EAAkC;AAChC,WAAM,IAAI1C,KAAJ,0EAAgF0C,SAAhF,yCAAgFA,SAAhF,SAAN;AACD,IAFD,MAEO,IAAIA,YAAY,CAAhB,EAAmB;AACxB,WAAM,IAAI1C,KAAJ,sCAA6C0C,SAA7C,OAAN;AACD;;AAED,OAAME,UAAUC,KAAKC,KAAL,CAAWJ,YAAY,IAAvB,CAAhB;AACA,UAAO,kBAAWrB,KAAX,EAAkBM,MAAlB,EAA0BiB,OAA1B,EAAmC,CAAnC,CAAP;AACD;;AAED;;;AAGO,UAAShD,MAAT,CAAgByB,KAAhB,EAAuBM,MAAvB,EAA+B;AACpC,OAAMiB,UAAU,kBAAWvB,KAAX,EAAkBM,MAAlB,EAA0B,CAA1B,CAAhB;AACA,UAAO,IAAIoB,IAAJ,CAASH,UAAU,IAAnB,CAAP;AACD,E;;;;;;;;;;;SCnBejD,M,GAAAA,M;SAiCAC,M,GAAAA,M;AAvChB;;;;;;AAMO,UAASD,MAAT,CAAgB0B,KAAhB,EAAuBM,MAAvB,EAA+BqB,MAA/B,EAAuCC,QAAvC,EAAiD;AACtD,OAAI,CAACZ,OAAOC,SAAP,CAAiBU,MAAjB,CAAL,EAA+B;AAC7B,WAAM,IAAIhD,KAAJ,6BAAN;AACD,IAFD,MAEO,IAAIgD,SAAS,CAAb,EAAgB;AACrB,WAAM,IAAIhD,KAAJ,wDAA+DgD,MAA/D,OAAN;AACD,IAFM,MAEA,IAAIC,WAAW,CAAf,EAAkB;AACvB,WAAM,IAAIjD,KAAJ,8DAAN;AACD,IAFM,MAEA,IAAIiD,WAAW,CAAf,EAAkB;AACvB,WAAM,IAAIjD,KAAJ,iEAAN;AACD;;AAED;AACA,OAAMkD,OAAOD,WAAW,CAAxB;AACA,OAAME,MAAMN,KAAKO,GAAL,CAAS,CAAT,EAAYF,IAAZ,IAAoB,CAAhC;AACA,OAAIF,SAASG,GAAb,EAAkB;AAChB,WAAM,IAAInD,KAAJ,eAAsBiD,QAAtB,8CAAuEE,GAAvE,cAAmFH,MAAnF,OAAN;AACD;;AAED;AACA,OAAMK,QAAQ1B,SAASsB,QAAvB;AACA,QAAK,IAAIhB,IAAIN,MAAb,EAAqBM,IAAIoB,KAAzB,EAAgCpB,GAAhC,EAAqC;AACnC;AACA;AACA;AACA;AACA,SAAMqB,WAAW,CAACD,QAAQpB,CAAR,GAAY,CAAb,IAAkB,CAAnC;AACAZ,WAAMY,CAAN,IAAW,OAAQe,UAAUM,QAA7B;AACD;AACF;;AAED;;;AAGO,UAAS1D,MAAT,CAAgByB,KAAhB,EAAuBM,MAAvB,EAA+BsB,QAA/B,EAAyC;AAC9C,OAAIA,WAAW,CAAX,IAAgBA,WAAW,CAA/B,EAAkC;AAChC,WAAM,IAAIjD,KAAJ,8DAAqEiD,QAArE,OAAN;AACD;;AAED,OAAID,SAAS,CAAb;AACA,OAAMK,QAAQ1B,SAASsB,QAAvB;;AAEA;AACA,QAAK,IAAIhB,IAAIN,MAAb,EAAqBM,IAAIoB,KAAzB,EAAgCpB,GAAhC,EAAqC;AACnC;AACA;AACA;AACA;AACA,SAAMqB,WAAW,CAACD,QAAQpB,CAAR,GAAY,CAAb,IAAkB,CAAnC;AACAe,cAASA,SAAU3B,MAAMY,CAAN,KAAYqB,QAA/B;AACD;;AAED,UAAON,MAAP;AACD,E;;;;;;;;;;;SCpDerD,M,GAAAA,M;SAsCAC,M,GAAAA,M;AA5ChB;;;;;;AAMO,UAASD,MAAT,CAAgB0B,KAAhB,EAAuBM,MAAvB,EAA+B1B,MAA/B,EAAuCqB,MAAvC,EAA+C;;AAEpD,OAAIiC,cAAc5B,MAAlB;AACA,OAAM6B,eAAevD,OAAOqB,MAA5B;;AAEA;AACA,QAAK,IAAIW,IAAI,CAAb,EAAgBA,IAAIuB,YAApB,EAAkCvB,GAAlC,EAAuC;;AAErC,SAAMwB,OAAOxD,OAAOgC,CAAP,CAAb;;AAEA;AACA,SAAMyB,YAAYC,kBAAkBF,IAAlB,CAAlB;;AAEA;AACA,SAAIF,cAAcG,UAAUpC,MAAxB,GAAiCK,SAASL,MAA9C,EAAsD;AACpD;AACD;;AAED;AACA,UAAK,IAAIsC,IAAI,CAAb,EAAgBA,IAAIF,UAAUpC,MAA9B,EAAsCsC,GAAtC,EAA2C;AACzCvC,aAAMkC,cAAcK,CAApB,IAAyBF,UAAUE,CAAV,CAAzB;AACD;;AAEDL,oBAAeG,UAAUpC,MAAzB;AACD;;AAED;AACA,OAAMuC,iBAAiBlC,SAASL,MAAT,GAAkBiC,WAAzC;AACA,QAAK,IAAItB,KAAI,CAAb,EAAgBA,KAAI4B,cAApB,EAAoC5B,IAApC,EAAyC;AACvCZ,WAAMmB,IAAN,CAAW,IAAX,EADuC,CACrB;AACnB;;AAED,UAAOnB,KAAP;AACD;;AAED;;;AAGO,UAASzB,MAAT,CAAgByB,KAAhB,EAAuBM,MAAvB,EAA+BL,MAA/B,EAAuC;;AAE5C,OAAMwC,cAAczC,MAAM0C,KAAN,CAAYpC,MAAZ,EAAoBA,SAASL,MAA7B,CAApB;AACA,OAAM0C,YAAYF,YAAYG,GAAZ,CAAgB,UAASnC,IAAT,EAAe;AAC/C,YAAOoC,OAAOC,aAAP,CAAqBrC,IAArB,CAAP;AACD,IAFiB,EAEfM,IAFe,CAEV,EAFU,CAAlB;;AAIA,UAAOgC,mBAAmBC,OAAOL,SAAP,CAAnB,EAAsCM,IAAtC,EAAP;AACD;;AAED;;;AAGA,UAASX,iBAAT,CAA2B1D,MAA3B,EAAmC;AACjC,UAAOsE,SAASC,mBAAmBvE,MAAnB,CAAT,EAAqCwE,KAArC,CAA2C,EAA3C,EAA+CR,GAA/C,CAAmD,UAASR,IAAT,EAAe;AACvE,YAAOA,KAAKvD,UAAL,CAAgB,CAAhB,CAAP;AACD,IAFM,CAAP;AAGD,E;;;;;;;;;;;;;;AC7DD;;;;AAEA;;;KAGqBwE,O;;AAEnB;;;AAGA,sBAAc;AAAA;;AACZ,UAAKrD,KAAL,GAAa,EAAb;AACA,UAAKM,MAAL,GAAc,CAAd;AACD;;AAED;;;;;;;;;;;;yBAQIgD,U,EAAqB;;AAEvB,WAAMC,gBAAgB,KAAKvD,KAAL,CAAWC,MAAjC;;AAFuB,yCAANuD,IAAM;AAANA,aAAM;AAAA;;AAGvBA,YAAKC,OAAL,CAAa,KAAKzD,KAAlB,EAAyB,KAAKM,MAA9B;;AAEA,WAAIoD,SAASJ,WAAWK,KAAX,CAAiBC,SAAjB,EAA4BJ,IAA5B,CAAb;AACA,YAAKlD,MAAL,IAAgB,KAAKN,KAAL,CAAWC,MAAX,GAAoBsD,aAApC;;AAEA,cAAOG,MAAP;AACD;;AAED;;;;;;;gCAIW;AACT,cAAO,KAAK1D,KAAL,CAAW4C,GAAX,CAAe,UAASnC,IAAT,EAAe;AACnC,gBAAOoC,OAAOC,aAAP,CAAqB,sBAAWrC,IAAX,CAArB,CAAP;AACD,QAFM,EAEJM,IAFI,CAEC,EAFD,CAAP;AAGD;;;;;;mBArCkBsC,O;;;;;;;;;;;SCFLQ,U,GAAAA,U;AAHhB;;;AAGO,UAASA,UAAT,CAAoBpD,IAApB,EAA0B;AAC/B,OAAI,CAACO,OAAOC,SAAP,CAAiBR,IAAjB,CAAL,EAA6B;AAC3B,WAAM,IAAI9B,KAAJ,8BAAqC8B,IAArC,OAAN;AACD,IAFD,MAEO,IAAIA,OAAO,CAAX,EAAc;AACnB,WAAM,IAAI9B,KAAJ,yBAAgC8B,IAAhC,WAAN;AACD,IAFM,MAEA,IAAIA,OAAO,GAAX,EAAgB;AACrB,WAAM,IAAI9B,KAAJ,yBAAgC8B,IAAhC,aAAN;AACD;;AAED,UAAOA,IAAP;AACD,E;;;;;;;;;;;;;;ACbD;;;;AAEA;;;KAGqBqD,O;;AAEnB;;;;;;AAMA,oBAAY9D,KAAZ,EAAmB;AAAA;;AACjB,UAAKM,MAAL,GAAc,CAAd;AACA,UAAKN,KAAL,GAAaA,KAAb;;AAEA,SAAI,OAAOA,KAAP,IAAiB,QAArB,EAA+B;AAC7B,YAAKA,KAAL,GAAa,KAAKA,KAAL,CAAWoD,KAAX,CAAiB,EAAjB,EAAqBR,GAArB,CAAyB,UAASR,IAAT,EAAe;AACnD,gBAAO,sBAAWA,KAAKvD,UAAL,CAAgB,CAAhB,CAAX,CAAP;AACD,QAFY,CAAb;AAGD;AACF;;AAED;;;;;;;;;;;;;;;yBAWIkF,U,EAAqB;AAAA,yCAANP,IAAM;AAANA,aAAM;AAAA;;AAEvB,WAAMQ,UAAUR,KAAKvD,MAAL,IAAe,CAAf,GAAmBuD,KAAKA,KAAKvD,MAAL,GAAc,CAAnB,CAAnB,GAA2C2D,SAA3D;;AAEAJ,YAAKC,OAAL,CAAa,KAAKzD,KAAlB,EAAyB,KAAKM,MAA9B;;AAEA,WAAIoD,SAASK,WAAWJ,KAAX,CAAiBC,SAAjB,EAA4BJ,IAA5B,CAAb;;AAEA,WAAIxC,OAAOC,SAAP,CAAiB+C,OAAjB,KAA6BA,WAAW,CAA5C,EAA+C;AAC7C,cAAK1D,MAAL,IAAe0D,OAAf;AACD,QAFD,MAEO;AACL,cAAK1D,MAAL;AACD;;AAED,cAAOoD,MAAP;AACD;;;;;;mBA7CkBI,O","file":"biosentiers-qrcode.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bioqr\"] = factory();\n\telse\n\t\troot[\"bioqr\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bc21311c10b991f905bc\n **/","import { encode as v0Encode, decode as v0Decode } from './formats/v0';\n\nconst bioqr = {\n  encode: encode,\n  decode: decode\n};\n\nfunction encode(data, options) {\n  switch (data.version) {\n    case 0:\n      return v0Encode(data, options);\n    default:\n      throw new Error(`Unknown format version ${data.version}`);\n  }\n}\n\nfunction decode(string, options) {\n  const version = string.charCodeAt(0);\n  switch (version) {\n    case 0:\n      return v0Decode(string, options);\n    default:\n      throw new Error(`String is not in a known format version ${version}`);\n  }\n}\n\nexport default bioqr;\nexport { encode, decode };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/biosentiers-qrcode.js\n **/","import { encode as encodeBitmask, decode as decodeBitmask } from '../binary/bitmask';\nimport { encode as encodeTimestamp, decode as decodeTimestamp } from '../binary/timestamp';\nimport { encode as encodeUint, decode as decodeUint } from '../binary/uint';\nimport { encode as encodeUtf8String, decode as decodeUtf8String } from '../binary/utf8-string';\nimport Encoder from '../binary/encoder';\nimport Decoder from '../binary/decoder';\n\nconst FORMAT_VERSION = 0;\nconst FORMAT_LENGTH = 134;\nconst CREATOR_NAME_LENGTH = 40;\nconst EXCURSION_ID_LENGTH = 5;\nconst EXCURSION_NAME_LENGTH = 60;\nconst PARTICIPANT_ID_LENGTH = 2;\nconst PARTICIPANT_NAME_LENGTH = 20;\nconst TYPES = [ 'bird', 'butterfly', 'flower', 'tree'  ];\n\nexport function encode(data, options) {\n  options = options || {};\n\n  var encoder = new Encoder();\n  encoder.add(encodeUint, FORMAT_VERSION, 1);\n  encoder.add(encodeUtf8String, data.creatorName, CREATOR_NAME_LENGTH);\n  encoder.add(encodeUtf8String, data.excursionId, EXCURSION_ID_LENGTH);\n  encoder.add(encodeTimestamp, data.excursionDate);\n  encoder.add(encodeUtf8String, data.excursionName, EXCURSION_NAME_LENGTH);\n  encoder.add(encodeUtf8String, data.participantId, PARTICIPANT_ID_LENGTH);\n  encoder.add(encodeUtf8String, data.participantName, PARTICIPANT_NAME_LENGTH);\n  encoder.add(encodeBitmask, data.types, options.types || TYPES);\n  encoder.add(encodeBitmask, data.zones);\n\n  if (encoder.bytes.length != FORMAT_LENGTH) {\n    throw new Error(`Format 0 byte length should be 134 (got ${encoder.bytes.length})`);\n  }\n\n  return encoder.toString();\n}\n\nexport function decode(string, options) {\n  options = options || {};\n\n  const decoder = new Decoder(string);\n  if (decoder.bytes.length != FORMAT_LENGTH) {\n    throw new Error(`Format 0 byte length should be 134 (got ${decoder.bytes.length})`);\n  }\n\n  const decoded = {};\n  decoded.version = decoder.get(decodeUint, 1);\n  decoded.creatorName = decoder.get(decodeUtf8String, CREATOR_NAME_LENGTH);\n  decoded.excursionId = decoder.get(decodeUtf8String, EXCURSION_ID_LENGTH);\n  decoded.excursionDate = decoder.get(decodeTimestamp, 4);\n  decoded.excursionName = decoder.get(decodeUtf8String, EXCURSION_NAME_LENGTH);\n  decoded.participantId = decoder.get(decodeUtf8String, PARTICIPANT_ID_LENGTH);\n  decoded.participantName = decoder.get(decodeUtf8String, PARTICIPANT_NAME_LENGTH);\n  decoded.types = decoder.get(decodeBitmask, TYPES);\n  decoded.zones = decoder.get(decodeBitmask);\n\n  return decoded;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/formats/v0.js\n **/","/**\n * Fills a byte array with a 1-byte bitmask that can be used to serialize up to 8 boolean flags.\n *\n * If no references are given, values must be numbers from 0 to 7.\n * For example, the values [ 1, 3 ] would be encoded as the integer 10 (or 00001010 in binary).\n *\n * If references are given, then each value must be one of the reference values.\n * The references array must not contain more than 32 items.\n * For example, the values [ 'foo', 'baz' ] with references [ 'foo', 'bar', 'baz' ]\n * would be encoded as the integer 5 (or 00000101 in binary).\n */\nexport function encode(bytes, offset, values, references) {\n  let byte = 0;\n\n  values.forEach(function(value, i) {\n\n    let bitmaskIndex = value;\n\n    // If references are given, convert the value to its index in the reference array\n    if (references) {\n      bitmaskIndex = references.indexOf(value);\n      if (bitmaskIndex < 0) {\n        throw new Error(`Unknown bitmask value ${value} (allowed: ${references.join(', ')})`);\n      } else if (bitmaskIndex > 7) {\n        throw new Error(`References have too many values (${references.length} > 32)`);\n      }\n    } else if (!Number.isInteger(bitmaskIndex) || bitmaskIndex < 0 || bitmaskIndex > 31) {\n      throw new Error(`Bitmask value ${i} must be an integer between 0 and 31 or one of the reference values (got ${bitmaskIndex})`);\n    }\n\n    // Set the correct bit to 1 in the bitmask\n    byte = byte | (1 << bitmaskIndex);\n  });\n\n  // Add the byte to the array\n  bytes[offset] = byte;\n}\n\n/**\n * Decodes up to 8 boolean flags from a 1-byte bitmask at the specified position in a byte array.\n *\n * If no references are given, the indices of the active flags are returned, e.g. [ 1, 3 ].\n *\n * If references are given, the indices are converted to the correspond reference values,\n * e.g. [ 'foo', 'baz' ] if the decoded flags are [ 0, 2 ] and the references are [ 'foo', 'bar', 'baz' ].\n */\nexport function decode(bytes, offset, references) {\n\n  const values = [];\n  const byte = bytes[offset];\n\n  // Iterate over the 8 bits\n  for (let i = 0; i < 8; i++) {\n    // Check whether the bit at the current position is 1\n    const mask = 1 << i;\n    if ((byte & mask) > 0) {\n      // Add the index (or reference value) to the result array if that is the case\n      if (!references) {\n        values.push(i);\n      } else if (references[i]) {\n        values.push(references[i]);\n      }\n    }\n  }\n\n  return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/bitmask.js\n **/","import { encode as encodeUint, decode as decodeUint } from '../binary/uint';\n\n/**\n * Fills a byte array with a 4-byte integer representing the specified date in minutes.\n * Seconds and milliseconds are lost in the conversion.\n */\nexport function encode(bytes, offset, dateOrTimestamp) {\n\n  const timestamp = typeof(dateOrTimestamp.getTime) == 'function' ? dateOrTimestamp.getTime() : dateOrTimestamp;\n  if (!Number.isInteger(timestamp)) {\n    throw new Error(`Timestamp must be an integer or a date (got a value of type ${typeof(timestamp)})`)\n  } else if (timestamp < 0) {\n    throw new Error(`Timestamp must be positive (got ${timestamp})`);\n  }\n\n  const minutes = Math.floor(timestamp / 1000);\n  return encodeUint(bytes, offset, minutes, 4);\n}\n\n/**\n * Decodes a date from a 4-byte number of minutes at the specified position in a byte array.\n */\nexport function decode(bytes, offset) {\n  const minutes = decodeUint(bytes, offset, 4);\n  return new Date(minutes * 1000);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/timestamp.js\n **/","/**\n * Fills a byte array with the specified integer's bytes (in big endian order).\n *\n * Unsigned integers may only be serialized up to a precision of 6 bytes\n * (JavaScript numbers are doubles with a significand of 52 bits).\n */\nexport function encode(bytes, offset, number, byteSize) {\n  if (!Number.isInteger(number)) {\n    throw new Error(`Number must be an integer`);\n  } else if (number < 0) {\n    throw new Error(`Unsigned integer cannot be smaller than zero (got ${number})`);\n  } else if (byteSize < 1) {\n    throw new Error(`Unsigned integer cannot be encoded with less than one byte`);\n  } else if (byteSize > 6) {\n    throw new Error(`Unsigned integer cannot be encoded with more than seven bytes`);\n  }\n\n  // Ensure the number is not larger than the maximum allowed by the specified byte size\n  const bits = byteSize * 8;\n  const max = Math.pow(2, bits) - 1;\n  if (number > max) {\n    throw new Error(`Unsigned ${byteSize} bytes integer cannot be greater than ${max} (got ${number})`);\n  }\n\n  // Add the specified number of bytes\n  const bound = offset + byteSize;\n  for (let i = offset; i < bound; i++) {\n    // For each byte, right-shift the number by the correct amount\n    // and take the last 8 bits (with & 0xFF) to obtain the byte to store at that position\n    // (e.g. for a 4 bytes integer, the first byte is right-shifted by 24,\n    // the second by 16, the third by 8 and the fourth by 0)\n    const bitShift = (bound - i - 1) * 8;\n    bytes[i] = 0xFF & (number >> bitShift);\n  }\n}\n\n/**\n * Decodes an unsigned integer's bytes from the specified portion of a byte array (in big endian order).\n */\nexport function decode(bytes, offset, byteSize) {\n  if (byteSize < 1 || byteSize > 6) {\n    throw new Error(`Unsigned integer byte size must be between 1 and 6 (got ${byteSize})`);\n  }\n\n  let number = 0;\n  const bound = offset + byteSize;\n\n  // Iterate byte by byte over the specified range (from offset to offset + byteSize)\n  for (let i = offset; i < bound; i++) {\n    // Shift each byte's bits by the correct amount\n    // and add them to the result number\n    // (e.g. for a 4 bytes integer, the first byte is left-shifted by 24,\n    // the second by 16, the third by 8 and the fourth by 0)\n    const bitShift = (bound - i - 1) * 8;\n    number = number | (bytes[i] << bitShift);\n  }\n\n  return number;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/uint.js\n **/","/**\n * Fills a byte array with the UTF-8 bytes of the specified string.\n *\n * If the string is longer than the specified length (in bytes), extra bytes are not serialized.\n * Extra spaces at the end of the string will be lost when decoding, as spaces are used for padding.\n */\nexport function encode(bytes, offset, string, length) {\n\n  let currentByte = offset;\n  const stringLength = string.length;\n\n  // For each character in the string...\n  for (let i = 0; i < stringLength; i++) {\n\n    const char = string[i];\n\n    // Convert the character to an array of UTF-8 bytes (1 to 4 bytes per character)\n    const utf8Bytes = stringToUtf8Bytes(char);\n\n    // Stop here if there are too many bytes (the rest of the string is ignored)\n    if (currentByte + utf8Bytes.length > offset + length) {\n      break;\n    }\n\n    // Add the character's UTF-8 bytes to the byte array\n    for (let j = 0; j < utf8Bytes.length; j++) {\n      bytes[currentByte + j] = utf8Bytes[j];\n    }\n\n    currentByte += utf8Bytes.length;\n  }\n\n  // If the string is not long enough to fill the expected length, pad it with spaces\n  const remainingBytes = offset + length - currentByte;\n  for (let i = 0; i < remainingBytes; i++) {\n    bytes.push(0x20); // space\n  }\n\n  return bytes;\n}\n\n/**\n * Decodes a string from the UTF-8 bytes in the specified portion of a byte array.\n */\nexport function decode(bytes, offset, length) {\n\n  const stringBytes = bytes.slice(offset, offset + length);\n  const rawString = stringBytes.map(function(byte) {\n    return String.fromCodePoint(byte);\n  }).join('');\n\n  return decodeURIComponent(escape(rawString)).trim();\n}\n\n/**\n * Convers a string to an array containing all its character's UTF-8 bytes (1 to 4 bytes per character).\n */\nfunction stringToUtf8Bytes(string) {\n  return unescape(encodeURIComponent(string)).split('').map(function(char) {\n    return char.charCodeAt(0);\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/utf8-string.js\n **/","import { ensureByte } from '../binary/byte';\n\n/**\n * Utility class to progressively build a byte array and keep track of the current offset.\n */\nexport default class Encoder {\n\n  /**\n   * Constructs an encoder with an empty byte array.\n   */\n  constructor() {\n    this.bytes = [];\n    this.offset = 0;\n  }\n\n  /**\n   * Calls the specified encoding function with this encoder's internal byte array, the\n   * current offset and the specified extra arguments. It's the responsibility of the\n   * encoding function to add more bytes to the array starting at the specified offset.\n   *\n   * The encoder will automatically increment its current offset by the number of new bytes\n   * added to the array, so subsequent calls will invoke encoding functions with greater offsets.\n   */\n  add(encodeFunc, ...args) {\n\n    const currentLength = this.bytes.length;\n    args.unshift(this.bytes, this.offset);\n\n    var result = encodeFunc.apply(undefined, args);\n    this.offset += (this.bytes.length - currentLength);\n\n    return result;\n  }\n\n  /**\n   * Converts this encoder's internal byte array to a string of characters that can\n   * all be represented with 1 byte in UTF-8.\n   */\n  toString() {\n    return this.bytes.map(function(byte) {\n      return String.fromCodePoint(ensureByte(byte));\n    }).join('');\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/encoder.js\n **/","/**\n * Returns the specified value unchanged, but throws an error if it is not an integer between 0 and 255.\n */\nexport function ensureByte(byte) {\n  if (!Number.isInteger(byte)) {\n    throw new Error(`Byte is not an integer (${byte})`);\n  } else if (byte < 0) {\n    throw new Error(`Byte is too small (${byte} < 0)`)\n  } else if (byte > 255) {\n    throw new Error(`Byte is too large (${byte} > 255)`);\n  }\n\n  return byte;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/byte.js\n **/","import { ensureByte } from '../binary/byte';\n\n/**\n * Utility class to progressively decode a byte array and keep track of the current offset.\n */\nexport default class Decoder {\n\n  /**\n   * Constructs a decoder for the specified byte array.\n   *\n   * A string can also be given in place of the byte array.\n   * It should contain only characters that can be represented with 1 byte in UTF-8.\n   */\n  constructor(bytes) {\n    this.offset = 0;\n    this.bytes = bytes;\n\n    if (typeof(bytes) == 'string') {\n      this.bytes = this.bytes.split('').map(function(char) {\n        return ensureByte(char.charCodeAt(0));\n      });\n    }\n  }\n\n  /**\n   * Calls the specified decoding function with this decoder's internal byte array, the\n   * current offset and the specified extra arguments, and returns the result. It's the\n   * responsibility of the decoding function to extract the relevant bytes from the array,\n   * starting at the specified offset.\n   *\n   * If the last argument passed to the decoding function is a positive integer, the\n   * decoder will interpret it as the number of bytes that have been decoded and increment\n   * the current offset by that value. Otherwise, it will assume that only 1 byte has been\n   * decoded. Add an extra number argument if that is not the case.\n   */\n  get(decodeFunc, ...args) {\n\n    const lastArg = args.length >= 1 ? args[args.length - 1] : undefined;\n\n    args.unshift(this.bytes, this.offset);\n\n    var result = decodeFunc.apply(undefined, args);\n\n    if (Number.isInteger(lastArg) && lastArg >= 1) {\n      this.offset += lastArg;\n    } else {\n      this.offset++;\n    }\n\n    return result;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binary/decoder.js\n **/"],"sourceRoot":""}